"""Finite State Machine for object lifecycle management.

This module implements a state machine that tracks the lifecycle of detected
objects, managing states like ACTIVE, STATIONARY, and PARKED. Key features:

- Reduces false notifications from parked vehicles
- Generates arrival/departure events
- Suppresses notifications for stationary/parked objects
- Velocity-based state transitions
- Distinguishes arriving objects from pre-existing parked objects

State Diagram:
```
TENTATIVE (< N frames)
    → ACTIVE (validated + has moved) → triggers ARRIVAL
        → STATIONARY (velocity ~0 for T seconds)
            → PARKED (stationary for P minutes)
                → ACTIVE (movement detected)
                    → exit frame = "Departure"
    → PARKED (validated + never moved) → deferred arrival decision
        → ACTIVE (moved within threshold) → triggers ARRIVAL (delayed)
        → stays PARKED (truly pre-existing) → NO arrival
```

Notification Rules:
- TENTATIVE → ACTIVE: triggers "arrival" notification (object moved into frame)
- TENTATIVE → PARKED: deferred - may trigger delayed arrival if object moves soon
- PARKED → ACTIVE (within delayed_arrival_threshold): triggers "arrival" (delayed)
- PARKED → ACTIVE (after threshold): NO arrival (pre-existing object leaving)
- ACTIVE → STATIONARY: no notification (still present)
- STATIONARY → PARKED: no notification (suppress alerts)
- PARKED → ACTIVE → exit: triggers "departure" notification
- ACTIVE → exit: triggers "departure" notification
"""

import logging
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional

logger = logging.getLogger(__name__)


class ObjectState(Enum):
    """State of a tracked object in the lifecycle."""

    TENTATIVE = "tentative"  # New detection, not yet validated
    ACTIVE = "active"  # Moving object, confirmed
    STATIONARY = "stationary"  # Object stopped (< 10 seconds)
    PARKED = "parked"  # Object parked (> 5 minutes)
    DEPARTED = "departed"  # Object has left the scene


class EventType(Enum):
    """Types of events generated by the state machine."""

    ARRIVAL = "arrival"  # New object entered scene
    DEPARTURE = "departure"  # Object left scene
    STATE_CHANGE = "state_change"  # Object changed state
    LOITERING = "loitering"  # Object stationary too long (alert)


@dataclass
class ObjectEvent:
    """Event generated by the state machine."""

    event_type: EventType
    track_id: int
    class_name: str
    class_id: int
    timestamp: float
    old_state: Optional[ObjectState] = None
    new_state: Optional[ObjectState] = None
    bbox: Optional[tuple[float, float, float, float]] = None
    confidence: float = 0.0
    duration_seconds: float = 0.0  # Time in previous state


@dataclass
class ObjectLifecycle:
    """Lifecycle state for a tracked object."""

    track_id: int
    class_id: int
    class_name: str
    state: ObjectState = ObjectState.TENTATIVE

    # Timing
    first_seen: float = field(default_factory=time.time)
    last_seen: float = field(default_factory=time.time)
    state_entered: float = field(default_factory=time.time)

    # Position and velocity
    last_x: float = 0.0
    last_y: float = 0.0
    last_width: float = 0.0
    last_height: float = 0.0
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    confidence: float = 0.0

    # Initial position tracking (for displacement-based movement detection)
    initial_x: float = 0.0
    initial_y: float = 0.0

    # Counters
    frame_count: int = 0
    stationary_frames: int = 0

    # Movement tracking - has this object ever shown significant movement?
    # Used to distinguish arriving objects from pre-existing parked objects
    has_ever_moved: bool = False

    # Whether we've already notified arrival for this object
    # Used to generate delayed arrivals for objects that were briefly stationary
    arrival_notified: bool = False

    @property
    def age_seconds(self) -> float:
        """Time since first detection."""
        return time.time() - self.first_seen

    @property
    def time_in_state(self) -> float:
        """Time in current state."""
        return time.time() - self.state_entered

    @property
    def time_since_seen(self) -> float:
        """Time since last detection."""
        return time.time() - self.last_seen

    @property
    def bbox(self) -> tuple[float, float, float, float]:
        """Current bounding box."""
        return (self.last_x, self.last_y, self.last_width, self.last_height)

    @property
    def speed(self) -> float:
        """Speed (magnitude of velocity)."""
        return (self.velocity_x ** 2 + self.velocity_y ** 2) ** 0.5

    @property
    def displacement(self) -> float:
        """Total displacement from initial position (normalized)."""
        dx = self.last_x - self.initial_x
        dy = self.last_y - self.initial_y
        return (dx ** 2 + dy ** 2) ** 0.5


class ObjectStateMachine:
    """Finite State Machine for object lifecycle management.

    Manages state transitions for tracked objects and generates events
    for arrivals, departures, and state changes.

    Example:
        >>> fsm = ObjectStateMachine()
        >>> for frame_tracks in video_tracks:
        ...     events = fsm.update(frame_tracks)
        ...     for event in events:
        ...         if event.event_type == EventType.ARRIVAL:
        ...             send_notification(event)
    """

    def __init__(
        self,
        validation_frames: int = 10,
        velocity_threshold: float = 0.002,
        displacement_threshold: float = 0.02,
        stationary_seconds: float = 10.0,
        parked_seconds: float = 300.0,
        lost_seconds: float = 5.0,
        loitering_seconds: float = 60.0,
        delayed_arrival_threshold: float = 60.0,
        fps: float = 30.0,
    ):
        """Initialize state machine.

        Args:
            validation_frames: Frames needed to confirm a track
            velocity_threshold: Min velocity to be considered moving (normalized)
            displacement_threshold: Min displacement from initial position to be
                considered "moved" (normalized). This is useful at low frame rates
                where velocity estimates are unreliable.
            stationary_seconds: Time without movement to become STATIONARY
            parked_seconds: Time stationary to become PARKED
            lost_seconds: Time without detection to consider departed
            loitering_seconds: Time stationary to trigger loitering alert
            delayed_arrival_threshold: If an object was parked for less than this
                many seconds before becoming active, generate a delayed arrival.
                This handles objects that arrive but are briefly stationary.
            fps: Expected frame rate for velocity calculations
        """
        self.validation_frames = validation_frames
        self.velocity_threshold = velocity_threshold
        self.displacement_threshold = displacement_threshold
        self.stationary_seconds = stationary_seconds
        self.parked_seconds = parked_seconds
        self.lost_seconds = lost_seconds
        self.loitering_seconds = loitering_seconds
        self.delayed_arrival_threshold = delayed_arrival_threshold
        self.fps = fps

        self._objects: dict[int, ObjectLifecycle] = {}
        self._departed: dict[int, ObjectLifecycle] = {}  # Recently departed

    def update(
        self,
        tracks: list,  # List of TrackedObject
    ) -> list[ObjectEvent]:
        """Update state machine with new tracks.

        Args:
            tracks: List of TrackedObject from the tracker

        Returns:
            List of events generated this frame
        """
        events = []
        current_time = time.time()
        seen_ids = set()

        for track in tracks:
            seen_ids.add(track.track_id)

            if track.track_id not in self._objects:
                # New object
                lifecycle = self._create_lifecycle(track)
                self._objects[track.track_id] = lifecycle
            else:
                # Update existing object
                lifecycle = self._objects[track.track_id]
                new_events = self._update_lifecycle(lifecycle, track)
                events.extend(new_events)

        # Check for departed objects
        departed_ids = []
        for track_id, lifecycle in self._objects.items():
            if track_id not in seen_ids:
                if lifecycle.time_since_seen > self.lost_seconds:
                    # Object has departed
                    event = self._handle_departure(lifecycle)
                    if event:
                        events.append(event)
                    departed_ids.append(track_id)

        # Move departed objects
        for track_id in departed_ids:
            lifecycle = self._objects.pop(track_id)
            lifecycle.state = ObjectState.DEPARTED
            self._departed[track_id] = lifecycle

        # Clean old departed objects (keep for 60 seconds for reference)
        self._departed = {
            tid: lc for tid, lc in self._departed.items()
            if lc.time_since_seen < 60.0
        }

        return events

    def _create_lifecycle(self, track) -> ObjectLifecycle:
        """Create lifecycle for new track."""
        return ObjectLifecycle(
            track_id=track.track_id,
            class_id=track.class_id,
            class_name=track.class_name,
            state=ObjectState.TENTATIVE,
            last_x=track.x,
            last_y=track.y,
            last_width=track.width,
            last_height=track.height,
            velocity_x=track.velocity_x,
            velocity_y=track.velocity_y,
            confidence=track.confidence,
            initial_x=track.x,  # Track initial position for displacement
            initial_y=track.y,
            frame_count=1,  # First frame counts
        )

    def _update_lifecycle(
        self,
        lifecycle: ObjectLifecycle,
        track,
    ) -> list[ObjectEvent]:
        """Update lifecycle with new track data."""
        events = []
        current_time = time.time()
        old_state = lifecycle.state

        # Update position and velocity
        lifecycle.last_x = track.x
        lifecycle.last_y = track.y
        lifecycle.last_width = track.width
        lifecycle.last_height = track.height
        lifecycle.velocity_x = track.velocity_x
        lifecycle.velocity_y = track.velocity_y
        lifecycle.confidence = track.confidence
        lifecycle.last_seen = current_time
        lifecycle.frame_count += 1

        # Check for movement - use both velocity AND displacement
        # Velocity check: instant speed from Kalman filter
        # Displacement check: total distance moved from initial position
        # At low frame rates (1 FPS), velocity estimates are unreliable, so
        # displacement provides a more robust movement indicator.
        has_velocity = lifecycle.speed > self.velocity_threshold
        has_displacement = lifecycle.displacement > self.displacement_threshold
        is_moving = has_velocity or has_displacement

        if is_moving:
            lifecycle.stationary_frames = 0
            lifecycle.has_ever_moved = True
        else:
            lifecycle.stationary_frames += 1

        # State transitions
        new_state = self._determine_state(lifecycle, is_moving)

        if new_state != old_state:
            duration = lifecycle.time_in_state
            lifecycle.state = new_state
            lifecycle.state_entered = current_time

            # Generate events for state transitions
            if old_state == ObjectState.TENTATIVE and new_state == ObjectState.ACTIVE:
                # Arrival event - object moved into frame
                events.append(ObjectEvent(
                    event_type=EventType.ARRIVAL,
                    track_id=lifecycle.track_id,
                    class_name=lifecycle.class_name,
                    class_id=lifecycle.class_id,
                    timestamp=current_time,
                    old_state=old_state,
                    new_state=new_state,
                    bbox=lifecycle.bbox,
                    confidence=lifecycle.confidence,
                ))
                lifecycle.arrival_notified = True
                logger.info(
                    f"ARRIVAL: {lifecycle.class_name} (track {lifecycle.track_id})"
                )
            elif old_state == ObjectState.TENTATIVE and new_state == ObjectState.PARKED:
                # Object never moved - skip ARRIVAL for now, treat as pre-existing
                # If it starts moving soon, we'll send a delayed arrival
                logger.debug(
                    f"Deferring ARRIVAL for {lifecycle.class_name} (track {lifecycle.track_id}) "
                    f"- not moving yet, may be pre-existing parked object"
                )
            elif old_state == ObjectState.PARKED and new_state == ObjectState.ACTIVE:
                # Object was parked and started moving
                # Check if we should send a delayed arrival
                if not lifecycle.arrival_notified:
                    if duration < self.delayed_arrival_threshold:
                        # Was parked briefly - this is likely a new arrival that
                        # was initially stationary (e.g., person walked in and stood still)
                        events.append(ObjectEvent(
                            event_type=EventType.ARRIVAL,
                            track_id=lifecycle.track_id,
                            class_name=lifecycle.class_name,
                            class_id=lifecycle.class_id,
                            timestamp=current_time,
                            old_state=old_state,
                            new_state=new_state,
                            bbox=lifecycle.bbox,
                            confidence=lifecycle.confidence,
                        ))
                        lifecycle.arrival_notified = True
                        logger.info(
                            f"ARRIVAL (delayed): {lifecycle.class_name} (track {lifecycle.track_id}) "
                            f"- was stationary for {duration:.1f}s before moving"
                        )
                    else:
                        # Was parked for a long time - likely truly pre-existing
                        logger.debug(
                            f"Skipping ARRIVAL for {lifecycle.class_name} (track {lifecycle.track_id}) "
                            f"- was parked for {duration:.1f}s, treating as pre-existing"
                        )

            # State change event
            events.append(ObjectEvent(
                event_type=EventType.STATE_CHANGE,
                track_id=lifecycle.track_id,
                class_name=lifecycle.class_name,
                class_id=lifecycle.class_id,
                timestamp=current_time,
                old_state=old_state,
                new_state=new_state,
                bbox=lifecycle.bbox,
                confidence=lifecycle.confidence,
                duration_seconds=duration,
            ))

        # Check for loitering
        if (lifecycle.state == ObjectState.STATIONARY and
                lifecycle.time_in_state > self.loitering_seconds):
            # Only send once per loitering period
            loiter_periods = int(lifecycle.time_in_state / self.loitering_seconds)
            if loiter_periods == 1:
                events.append(ObjectEvent(
                    event_type=EventType.LOITERING,
                    track_id=lifecycle.track_id,
                    class_name=lifecycle.class_name,
                    class_id=lifecycle.class_id,
                    timestamp=current_time,
                    new_state=lifecycle.state,
                    bbox=lifecycle.bbox,
                    confidence=lifecycle.confidence,
                    duration_seconds=lifecycle.time_in_state,
                ))
                logger.info(
                    f"LOITERING: {lifecycle.class_name} (track {lifecycle.track_id}) "
                    f"stationary for {lifecycle.time_in_state:.1f}s"
                )

        return events

    def _determine_state(
        self,
        lifecycle: ObjectLifecycle,
        is_moving: bool,
    ) -> ObjectState:
        """Determine the appropriate state based on lifecycle."""
        current = lifecycle.state

        if current == ObjectState.TENTATIVE:
            if lifecycle.frame_count >= self.validation_frames:
                # Object confirmed - check if it ever moved
                if lifecycle.has_ever_moved:
                    # Normal arrival - object moved into frame
                    return ObjectState.ACTIVE
                else:
                    # Object never moved - likely pre-existing parked object
                    # Skip ACTIVE state and go directly to PARKED (no ARRIVAL event)
                    return ObjectState.PARKED
            return ObjectState.TENTATIVE

        elif current == ObjectState.ACTIVE:
            if not is_moving:
                stationary_time = lifecycle.stationary_frames / self.fps
                if stationary_time >= self.stationary_seconds:
                    return ObjectState.STATIONARY
            return ObjectState.ACTIVE

        elif current == ObjectState.STATIONARY:
            if is_moving:
                return ObjectState.ACTIVE
            if lifecycle.time_in_state >= self.parked_seconds:
                return ObjectState.PARKED
            return ObjectState.STATIONARY

        elif current == ObjectState.PARKED:
            if is_moving:
                return ObjectState.ACTIVE
            return ObjectState.PARKED

        return current

    def _handle_departure(self, lifecycle: ObjectLifecycle) -> Optional[ObjectEvent]:
        """Handle object departure."""
        # Only generate departure for confirmed objects
        if lifecycle.state in (ObjectState.TENTATIVE,):
            return None

        # Don't generate departure for parked objects that just weren't detected
        # They might still be there
        if lifecycle.state == ObjectState.PARKED:
            logger.debug(
                f"Parked object {lifecycle.track_id} lost, not generating departure"
            )
            return None

        logger.info(
            f"DEPARTURE: {lifecycle.class_name} (track {lifecycle.track_id})"
        )

        return ObjectEvent(
            event_type=EventType.DEPARTURE,
            track_id=lifecycle.track_id,
            class_name=lifecycle.class_name,
            class_id=lifecycle.class_id,
            timestamp=time.time(),
            old_state=lifecycle.state,
            new_state=ObjectState.DEPARTED,
            bbox=lifecycle.bbox,
            confidence=lifecycle.confidence,
            duration_seconds=lifecycle.age_seconds,
        )

    def get_lifecycle(self, track_id: int) -> Optional[ObjectLifecycle]:
        """Get lifecycle for a track ID."""
        return self._objects.get(track_id) or self._departed.get(track_id)

    def get_active_objects(self) -> list[ObjectLifecycle]:
        """Get all active (non-parked) objects."""
        return [
            lc for lc in self._objects.values()
            if lc.state in (ObjectState.ACTIVE, ObjectState.STATIONARY)
        ]

    def get_parked_objects(self) -> list[ObjectLifecycle]:
        """Get all parked objects."""
        return [
            lc for lc in self._objects.values()
            if lc.state == ObjectState.PARKED
        ]

    def should_notify(self, event: ObjectEvent) -> bool:
        """Determine if an event should trigger a notification.

        Args:
            event: Event to check

        Returns:
            True if event should trigger notification
        """
        if event.event_type == EventType.ARRIVAL:
            return True

        if event.event_type == EventType.DEPARTURE:
            return True

        if event.event_type == EventType.LOITERING:
            # Loitering is optional - could be configurable
            return True

        # State changes typically don't need notifications
        return False

    def reset(self) -> None:
        """Reset state machine."""
        self._objects.clear()
        self._departed.clear()

    @property
    def stats(self) -> dict:
        """Get state machine statistics."""
        state_counts = {}
        for state in ObjectState:
            state_counts[state.value] = sum(
                1 for lc in self._objects.values() if lc.state == state
            )

        return {
            "total_objects": len(self._objects),
            "departed_recently": len(self._departed),
            "by_state": state_counts,
        }
